{"version":3,"sources":["../src/main.ts","../src/middleware.ts","../src/hooks.ts"],"sourcesContent":["import { produce } from 'immer';\nimport { useSyncExternalStore } from 'react';\nimport {\n  ActionFunction,\n  OmitFirstParameter,\n  WrappedActionsType,\n  WrappedActionsTypePromise,\n} from './type';\nimport MiddlewareManager, { Middleware } from './middleware';\nimport { History, Hooks } from './hooks';\nclass createZoxy<T, K extends Record<string, ActionFunction<T>>> {\n  private subscribers: Set<(state: T) => void>;\n  private state: T;\n  public historyManager: History<T, K>;\n  private hooks: Hooks<T>;\n  public actions: WrappedActionsType<K>;\n  private middlewareManager: MiddlewareManager<T, K>;\n  constructor(initialState: T, actions: K, middlewares?: Middleware<T, K>[]) {\n    this.state = initialState;\n    this.subscribers = new Set();\n    this.actions = this.createActions(actions);\n    this.middlewareManager = new MiddlewareManager<T, K>(middlewares);\n    this.hooks = new Hooks<T>();\n    this.historyManager = new History<T, K>(this);\n  }\n\n  private createActions(actions: K) {\n    const wrappedActions = {} as WrappedActionsType<K>;\n    Object.entries(actions).forEach(([name, fn]) => {\n      wrappedActions[name as keyof K] = async (\n        ...params: OmitFirstParameter<K[keyof K]>\n      ) => {\n        const action = { type: name, fn, params };\n        await this.middlewareManager.applyMiddleware(\n          this,\n          action as WrappedActionsTypePromise<K>\n        );\n        if (this.hooks.isAsync(fn)) {\n          const promise = (async () => {\n            await (fn as any)(this.state, ...params);\n            this.setState(this.state);\n            this.historyManager.saveState();\n            return this.state;\n          })();\n          return promise;\n        }\n\n        const newState = produce(this.state, (draft: T) => {\n          fn(draft, ...params);\n        });\n        this.setState(newState);\n        this.historyManager.saveState();\n      };\n    });\n    return wrappedActions;\n  }\n\n  private notifySubscribers() {\n    this.subscribers.forEach((subscriber) => subscriber(this.state));\n  }\n\n  public subscribe(callback: (state: T) => void) {\n    this.subscribers.add(callback);\n    callback(this.state);\n    return () => this.unsubscribe(callback);\n  }\n\n  private unsubscribe(callback: (state: T) => void) {\n    this.subscribers.delete(callback);\n  }\n\n  public setState(newState: T) {\n    this.state = newState;\n    this.notifySubscribers();\n  }\n\n  public getState(): T {\n    return this.state;\n  }\n}\n\nconst useZoxy = <T>(store: createZoxy<T, any>) => {\n  return useSyncExternalStore(\n    store.subscribe.bind(store),\n    store.getState.bind(store),\n    store.getState.bind(store)\n  );\n};\n\nexport { createZoxy as create, useZoxy as useStore };\n","import { ActionFunction, WrappedActionsTypePromise } from './type';\r\n\r\nexport type Middleware<T, K extends Record<string, ActionFunction<T>>> = (\r\n  store: any,\r\n  next: (action: WrappedActionsTypePromise<K>) => Promise<void>,\r\n  action: WrappedActionsTypePromise<K>\r\n) => void | Promise<void>;\r\n\r\nclass MiddlewareManager<T, K extends Record<string, ActionFunction<T>>> {\r\n  private middlewares: Middleware<T, K>[] = [];\r\n  constructor(middlewares: Middleware<T, K>[] = []) {\r\n    this.middlewares = middlewares;\r\n  }\r\n\r\n  public async applyMiddleware(\r\n    store: any,\r\n    action: WrappedActionsTypePromise<K>\r\n  ) {\r\n    let nextCalled = false;\r\n    const next = async () => {\r\n      nextCalled = true;\r\n    };\r\n    for (const middleware of this.middlewares) {\r\n      const result = middleware(store, next, action);\r\n\r\n      if (result instanceof Promise) {\r\n        await result;\r\n      }\r\n\r\n      if (nextCalled) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  public addMiddleware(middleware: Middleware<T, K>) {\r\n    this.middlewares.push(middleware);\r\n  }\r\n}\r\nexport default MiddlewareManager;\r\n","import { create } from './main';\r\nimport { ActionFunction } from './type';\r\n\r\nclass Hooks<T> {\r\n  constructor() {}\r\n  public isAsync(fn: ActionFunction<T>) {\r\n    return fn.constructor.name === 'AsyncFunction';\r\n  }\r\n}\r\n\r\nclass History<T, K extends Record<string, ActionFunction<T>>> {\r\n  history: T[] = [];\r\n  future: T[] = [];\r\n  constructor(private store: create<T, K>) {\r\n    this.store = store;\r\n  }\r\n\r\n  public saveState() {\r\n    this.history.push({ ...this.store.getState() });\r\n    this.future = [];\r\n  }\r\n\r\n  public async undo() {\r\n    if (this.history.length > 0) {\r\n      const lastAction = this.history.pop();\r\n      if (lastAction) {\r\n        this.future.push(lastAction);\r\n        this.store.setState(lastAction);\r\n      }\r\n    }\r\n  }\r\n\r\n  public async redo() {\r\n    if (this.future.length > 0) {\r\n      const lastAction = this.future.pop();\r\n      if (lastAction) {\r\n        this.history.push(lastAction);\r\n        this.store.setState(lastAction);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport { History, Hooks };\r\n"],"mappings":"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","names":[]}